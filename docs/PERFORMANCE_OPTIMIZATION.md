# 数据查询与同步性能优化文档

## 优化目标
- 减少不必要的数据库查询
- 优先使用 localStorage 缓存
- 智能判断数据新鲜度
- 延迟同步非关键数据
- 批量更新减少请求次数

---

## 数据分类与优化策略

### 1. 高频变化数据（每次专注都变）

**数据类型：**
- 今日专注时长 (`todayStats`)
- 本周专注时长 (`weeklyStats`)
- 总专注时长 (`totalFocusMinutes`)

**优化策略：**
- ✅ **优先 localStorage**：立即读取和写入
- ✅ **缓存时间**：5分钟
- ✅ **同步时机**：专注完成后延迟2秒批量同步
- ✅ **查询频率**：仅在缓存过期（>5分钟）或首次加载时查询

**实现位置：**
- `useDashboardData.ts` - 第104-130行
- 缓存过期判断：45分钟后才后台同步

---

### 2. 中频变化数据（每天最多变一次）

**数据类型：**
- 连续专注天数 (`streakDays`)
- 每日登录经验值

**优化策略：**
- ✅ **优先 localStorage**：立即读取
- ✅ **缓存时间**：24小时
- ✅ **同步时机**：达成条件后延迟3秒同步
- ✅ **查询频率**：每天首次访问时查询，其余时间使用缓存
- ✅ **防重复**：使用 `streakUpdated_{date}` 标记，每天只更新一次

**实现位置：**
- `dashboard/index.tsx` - 第1227-1248行
- 延迟3秒同步到数据库

**关键代码：**
```typescript
// 标记今天已更新，防止重复
localStorage.setItem(`streakUpdated_${today}`, 'true');

// 延迟3秒同步
setTimeout(() => {
  fetch('/api/user/stats/update', { ... });
}, 3000);
```

---

### 3. 低频变化数据（行为触发）

**数据类型：**
- 用户等级经验值 (`userExp`)
- 心树经验值 (`heartTreeExp`)

**优化策略：**
- ✅ **优先 localStorage**：立即读取和写入
- ✅ **缓存时间**：1小时
- ✅ **同步时机**：行为触发后延迟500ms同步
- ✅ **查询频率**：超过1小时才查询数据库
- ✅ **立即显示**：先显示 localStorage，后台验证

**实现位置：**
- `useUserExp.ts` - 第103-136行
- `useHeartTreeExp.ts` - 类似逻辑

**关键优化：**
```typescript
// 立即显示 localStorage 数据
const localExp = readLocalExp();
setUserExp(localExp);
setIsLoading(false);

// 仅在超过1小时时才查询数据库
if (needSync) {
  loadFromDatabase();
}

// 更新时延迟500ms同步
setTimeout(async () => {
  await fetch('/api/user/exp/update', { ... });
}, 500);
```

---

### 4. 极低频数据（偶尔变化）

**数据类型：**
- 成就 (`achievements`)
- 计划结构 (`projects`)

**优化策略：**
- ✅ **优先 localStorage**：立即读取
- ✅ **缓存时间**：
  - 成就：24小时
  - 计划：1小时
- ✅ **同步时机**：触发后延迟800ms同步
- ✅ **查询频率**：
  - 成就：超过24小时才查询
  - 计划：超过1小时才查询
- ✅ **跳过后台同步**：缓存有效期内完全不查询数据库

**实现位置：**
- `useAchievements.ts` - 第55-90行
- `useProjects.ts` - 第108-137行

**关键优化：**
```typescript
// 成就：24小时缓存
if (hoursSinceSync > 24) {
  loadFromDatabase();
} else {
  console.log('⚡ 跳过数据库查询（缓存有效）');
}

// 计划：1小时缓存
if (hoursSinceSync > 1) {
  loadFromDatabase();
} else {
  console.log('⚡ 跳过数据库查询（缓存有效）');
}
```

---

## 数据同步时间线（专注完成后）

### 时间轴：

**T+0ms（立即）：**
- ✅ 更新 localStorage（所有数据）
- ✅ 更新前端状态
- ✅ 显示完成动画

**T+500ms：**
- ✅ 同步用户经验值到数据库

**T+800ms：**
- ✅ 同步成就到数据库（如果有新成就）

**T+2000ms：**
- ✅ 刷新 Dashboard 统计数据（从数据库）

**T+3000ms：**
- ✅ 同步连续天数到数据库（如果今天首次达标）

---

## 查询频率对比

### 优化前：
- 每次进入 Dashboard：4-5次数据库查询
- 专注完成后：立即查询所有数据
- 成就检查：每2秒轮询一次
- 计划数据：每次都后台同步

### 优化后：
- 首次进入 Dashboard：2-3次数据库查询（必要数据）
- 后续进入：0-1次查询（大部分使用缓存）
- 专注完成后：延迟分批同步，避免阻塞
- 成就检查：仅在触发时同步
- 计划数据：1小时内完全不查询

---

## 缓存策略总结

| 数据类型 | 变化频率 | 缓存时间 | 查询条件 | 同步延迟 |
|---------|---------|---------|---------|---------|
| 今日专注时长 | 高频 | 5分钟 | >45分钟 | 2秒 |
| 本周专注时长 | 高频 | 5分钟 | >45分钟 | 2秒 |
| 连续天数 | 中频 | 24小时 | 每天首次 | 3秒 |
| 用户经验 | 低频 | 1小时 | >1小时 | 500ms |
| 心树经验 | 低频 | 1小时 | >1小时 | 500ms |
| 成就 | 极低频 | 24小时 | >24小时 | 800ms |
| 计划 | 极低频 | 1小时 | >1小时 | 立即 |

---

## 性能提升预期

### 页面加载速度：
- 首次加载：减少 40% 的数据库查询
- 后续加载：减少 70-80% 的数据库查询
- 缓存命中率：预计 85% 以上

### 用户体验：
- ✅ 数据显示更快（立即显示缓存）
- ✅ 专注完成不卡顿（延迟同步）
- ✅ 切换页面更流畅（减少查询）

### 数据库负载：
- 查询次数：减少 60-70%
- 写入次数：保持不变（必要的同步）
- 并发压力：分散到不同时间点

---

## 数据一致性保证

### 1. 写入优先
- 所有更新先写入 localStorage
- 延迟同步到数据库
- 即使数据库失败，用户数据也不丢失

### 2. 冲突解决
- 对比 localStorage 和数据库
- 取较大值（经验值、时长等）
- 自动修复数据不一致

### 3. 时间戳验证
- 每次同步记录时间戳
- 根据时间戳判断是否需要刷新
- 避免频繁的无效查询

---

## 关键优化点

### ✅ 1. 立即显示缓存
```typescript
// 优化前：等待数据库返回
if (status === 'authenticated') {
  loadFromDatabase(); // 阻塞等待
}

// 优化后：立即显示缓存
const cached = loadFromCache();
setData(cached);
setIsLoading(false);

// 后台验证（仅在需要时）
if (needSync) {
  loadFromDatabase();
}
```

### ✅ 2. 智能缓存判断
```typescript
// 根据数据类型设置不同的缓存时间
const needSync = !synced || !lastSyncAt || isDataStale(lastSyncAt);

// 高频数据：5分钟
// 中频数据：24小时
// 低频数据：1小时
// 极低频数据：24小时
```

### ✅ 3. 延迟同步
```typescript
// 优化前：立即同步（阻塞UI）
await fetch('/api/update', { ... });

// 优化后：延迟同步（不阻塞）
setTimeout(async () => {
  await fetch('/api/update', { ... });
}, delayMs);
```

### ✅ 4. 批量更新
```typescript
// 专注完成后收集所有更新
const batchUpdates = {
  todayMinutes,
  weeklyMinutes,
  streakDays,
  userExp,
};

// 一次性同步（未来可实现）
await fetch('/api/dashboard/batch-update', {
  body: JSON.stringify(batchUpdates)
});
```

---

## 监控与日志

### 性能日志标识：
- `⚡` - 使用缓存（性能优化）
- `📊` - 需要同步数据
- `💾` - 数据已缓存
- `✅` - 同步成功
- `⚠️` - 同步失败但不影响使用

### 示例日志：
```
[useProjects] ⚡ 使用缓存计划数据（性能优化）
[useProjects] ⚡ 跳过数据库查询（缓存有效）
[useAchievements] ⚡ 跳过数据库查询（缓存有效，极低频数据）
[useUserExp] 📊 经验值需要同步（首次或超过1小时）
[Dashboard] 🔄 检测到专注完成，刷新统计数据...
```

---

## 注意事项

### ⚠️ 数据一致性
- 所有更新都先写入 localStorage
- 数据库同步失败不影响用户体验
- 下次同步时会自动修复不一致

### ⚠️ 缓存失效
- 用户手动刷新会强制重新查询
- 检测到数据不一致会自动同步
- 跨设备登录会优先使用数据库数据

### ⚠️ 离线支持
- 所有数据都有 localStorage 备份
- 离线时完全可用
- 上线后自动同步

---

## 未来优化方向

1. **批量更新 API**
   - 实现 `/api/dashboard/batch-update` 端点
   - 一次请求更新所有数据
   - 减少 HTTP 请求次数

2. **WebSocket 实时同步**
   - 跨设备实时同步
   - 减少轮询查询
   - 降低服务器压力

3. **Service Worker 缓存**
   - 离线完全可用
   - 后台自动同步
   - 更好的性能

4. **增量同步**
   - 只同步变化的数据
   - 减少传输数据量
   - 提升同步速度

---

## 性能测试建议

### 测试场景：
1. 首次登录（冷启动）
2. 后续访问（热启动）
3. 专注完成后刷新
4. 跨页面切换
5. 离线使用

### 监控指标：
- 页面加载时间
- 数据库查询次数
- 缓存命中率
- 数据同步延迟
- 用户感知延迟

---

*最后更新：2025-12-27*
